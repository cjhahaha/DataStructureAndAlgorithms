# README
## 第一题
设计算法，将存有n(n>0)个数的数组A中的元素A[0]至A[n-1]循环右 移k(k>0)位，要求只允许使用一个元素大小的附加存储，元素移 动或交换次数为O(n)。

设数组为a，长度为len。

首先考虑两个特殊情况
1. `k = 0`，不用移动
2. `k >= len`时，显然移动k位的结果和移动`k % len`位的结果相同，所以
```c
if (k >= len) k %= len;
```

接着考虑一般情况
假设k=3吧，数组从0开始，长度是5，这样方便描述。
我们要做的是把a[0]移到a[3],a[3]移到a[1]，a[1]移到a[4]，a[4]移到a[2]，a[2]移到a[0]。总得来说，就是把a[i]移到a[(i + k) % len]上。什么时候结束呢？我们之前说的这个例子是从0开始，到0结束。所以我们很显然的发现，如果重新回到起点，就结束了。即
```c
temp = a[i];
j = i;
do {
    j = (j + k) % len;
    swap(a[j], temp);
} while (j != i);
```
好了，考虑另一个情况，k=3，长度是6。这样有什么区别呢？我们来看一看。
1. 把a[0]移到a[3]，a[3]移动到a[0] \\
诶，怎么就结束了？那么我们还需要进行下面两个步骤
2. 把a[1]移到a[4]，a[4]移动到a[1]
3. 把a[2]移到a[5]，a[5]移动到a[2]
这次的话，我们一共进行了3次上述的循环！

那么问题来了，我们到底要进行多少次上述循环呢？答案是`gcd(len, k)`次，其中`gcd`是最大公约数。
证明如下：
从i开始，每次i = (i + k) % len，直到回到起点，假设一个进行n次，即：
$$
i + nk \equiv i \pmod{len}
$$
显然
$$
len \  | \ nk 
$$
n是最小的满足以上条件的n，显然我们能找到一个m，使得
$$
m \  len = nk \\
n = m\frac{len}{k}
$$
因为n是整数，所以
$$
k \ | \ m \  len \\
m = \frac{k}{gcd(k, len)}
$$
$$
n = \frac{len}{gcd(k, len)}
$$
所以每次能够移动$n$个数，一共有$len$个数需要移动，所以需要
$$
\frac{len}{n} = gcd(k, len)
$$
次移动。

## 第二题
用循环队列编写求k阶斐波那契序列中前n+1项$(f_1,f_2,...,f_n)$的算法 ，要求满足$f_n \leq max$，而$f_{n+1} \gt max$, $max$为某个约定的常数，注意：本题所用循环队列的容量为k，算法结束时，留在队列中的元 素为所求k阶斐波那契序列中的最后k项。


